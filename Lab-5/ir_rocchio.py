# -*- coding: utf-8 -*-
"""IR_Rocchio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UYtatpluwPylgTHYrNU4OLn3DlULH89a

https://nlp.stanford.edu/IR-book/html/htmledition/rocchio-classification-1.html
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# % cd /content/drive/MyDrive/Colab Notebooks/IR/Lab6/matlab

import numpy as np

doc_word_mapper = {}
l_list=[]
index_dict={}
freq_dict={}




word_class_mapper = {} # (word, class): count
label_count_mapper = np.zeros(20) # since i know total number of docs I'm making this array directly
class_docs = {}
train_y = []

with open('./train.label', 'r') as fp:
  for line in fp:
    label = int(line.strip())
    # its good to point out that doc_id 'n' will have label at 'n-1'th place
    # in simple words doc0 will have label at train_y[0] which will be between 1-20
    train_y.append(label)
    class_docs[label] = class_docs.get(label, 0) 


i=0
with open('./train.data', 'r') as fp:
    for line in fp:
      doc_id, word_id, count = line.strip().split(' ')
      #doc_word_mapper[(int(doc_id), int(word_id))] = int(count)
      if word_id not in l_list:
        index_dict[word_id] = i
        i+=1
        l_list.append(word_id)
      #else:
      #  print("inlist")

len(l_list)

import numpy as np
class_vectors=np.zeros((20,len(l_list)))
class_count=np.zeros(20)

class_vectors.shape

len(l_list)

previous_doc=1
with open('./train.data', 'r') as fp:
  temp=np.zeros(len(l_list))
  total_count=0
  for line in fp:
    doc_id, word_id, count = line.strip().split(' ')
    #print(word_id)
    doc_id=int(doc_id)
    if previous_doc != doc_id:
      #break
      #print(train_y[int(previous_doc)]-1)
      class_vectors[train_y[int(previous_doc)]-1,:]+=(temp/total_count)
      class_count[train_y[int(previous_doc)]-1]+=1
      temp=np.zeros(len(l_list))
      temp[index_dict[word_id]]=int(count)
      total_count=0
      previous_doc=int(doc_id)
    else:
      temp[index_dict[word_id]]=int(count)
      total_count+=int(count)

for i in range(20):
  class_vectors[i]=class_vectors[i]/class_count[i]

class_vectors[0]

"""Testing"""

import numpy as np
def cosine(a,class_vectors):
  a=np.array(a)
  class_vectors=np.array(class_vectors)
  dist=np.zeros(20,dtype=np.float64)
  for i in range(20):
    dist[i]=np.sum(abs(a-class_vectors[i]))
  return np.argmin(dist)

previous_doc = 1
y_expected = []
conf_matrix=np.zeros((20,20))
with open('./train.label', 'r') as fp:
  for line in fp:
    y_expected.append(int(line.strip()))
total_test_docs = len(y_expected)
correct_classified = 0
with open('./train.data', 'r') as fp:
  j = 0
  temp=np.zeros(len(l_list))
  total_count=0
  for line in fp:
    doc_id, word_id, count = line.strip().split(' ')

    doc_id=int(doc_id)

    
    if previous_doc != doc_id:
      
      #################Check COsine##########################
      original=y_expected[int(previous_doc)-1]
      original-=1  ############to make range 0-19
      temp=temp/total_count
      predicted=cosine(temp,class_vectors)
      print(original,predicted)
      if (predicted==original):
        correct_classified+=1
      conf_matrix[original][predicted]+=1
      temp=np.zeros(len(l_list))
      previous_doc=doc_id
      
      if word_id not in l_list:  ###############if word is not in list then ignore
        continue
      temp[index_dict[word_id]]=int(count)
      total_count+=  int(count)
  
    else:
      #print("else")  
      if word_id not in l_list:  ###############if word is not in list then ignore
        print(word_id)
        continue
      else:
        #print(word_id)
        #print("here")
        temp[index_dict[word_id]]=int(count)
      
      
incorrect_classified = total_test_docs - correct_classified
print(correct_classified/total_test_docs)

np.max(temp)

"""Precision Recall F-Score

https://medium.com/data-science-in-your-pocket/calculating-precision-recall-for-multi-class-classification-9055931ee229
"""

conf_matrix

precision=np.zeros(20)
recall=np.zeros(20)
for i in range(20):
  temp=0
  for j in range(20):
    temp+=conf_matrix[i][j]
  precision[i]=conf_matrix[i][i]/float(temp)

for j in range(20):
  temp=0
  for i in range(20):
    temp+=conf_matrix[i][j]
  recall[j]=conf_matrix[j][j]/float(temp)

print(precision)
print(recall)

Precision=np.average(precision)
Recall=np.average(recall)
print(Precision,Recall)

F_Measure = (2 * Precision * Recall) / (Precision + Recall)
print(F_Measure)